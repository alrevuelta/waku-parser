package parser

import (
	"sync"
	"time"

	log "github.com/sirupsen/logrus"
)

type Message struct {
	Hash      string
	Timestamp time.Time
	Container string // TODO: publisher or subscriber
	Acks      []Ack  // container that acks the messages. TODO: store ack and time!. maybe acks should be a map
}

type Ack struct {
	container string
	time      time.Time
}

// There are two ways a message is removed from the stats:
// --all acks received (which should cover most of the cases)
// --a given timeout has passed, so we consider the message as lost.
// (tricky thing is how to check the times. my machine time may be different from the container time.)

type MessageStats struct {
	// msgHash to Message
	msgs              map[string]*Message
	mutex             sync.RWMutex
	totalPeers        int // unused?
	receivers         []string
	lastPublishedTime time.Time

	// TODO: some configuration about the timeout to consider a message lost
	messageTimeout time.Duration
}

type IntervalStats struct {
	// TODO: interval time blabla
	MsgSent     int
	MsgReceived int
	AvgDelay    time.Duration
	// TODO: some stuff about the delay times.
}

func NewMessage(hash string, timestampNs uint64, container string) *Message {
	return &Message{
		Hash:      hash,
		Timestamp: time.Unix(0, int64(timestampNs)),
		Container: container,
		Acks:      make([]Ack, 0),
	}
}

// receivers is a list of containers that are interested in the messages
// nwaku-1, nwaku-2, etc.
func NewMessageStats(receivers []string, timeoutInMilSec uint64) *MessageStats {
	return &MessageStats{
		msgs:           make(map[string]*Message),
		mutex:          sync.RWMutex{},
		totalPeers:     0,
		receivers:      receivers,
		messageTimeout: time.Duration(timeoutInMilSec * uint64(time.Millisecond)), // experiments
	}
}

func (m *MessageStats) SentMessage(msg *Message) {
	m.mutex.Lock()

	_, found := m.msgs[msg.Hash]
	if found {
		log.Fatal("Duplicate msg, something is wrong? TODO")
	}
	m.msgs[msg.Hash] = msg

	// update also the last published time
	//if msg.Time > m.lastPublishedTime {
	if msg.Timestamp.Compare(m.lastPublishedTime) > 0 {
		m.lastPublishedTime = msg.Timestamp
	}
	m.mutex.Unlock()
}

func (m *MessageStats) LastPubTime() time.Time {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return m.lastPublishedTime
}

func (m *MessageStats) WasMsgPublished(msg *Message) bool {
	m.mutex.RLock()
	defer m.mutex.RUnlock()

	_, found := m.msgs[msg.Hash]
	if found {
		return true
	}
	return false
}

func (m *MessageStats) ReceivedMessage(msg *Message) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	_, found := m.msgs[msg.Hash]
	if !found {
		log.Warn("Received a msg that was never sent: hash:", msg.Hash)
		return
	}

	// TODO: Perhaps warn on duplicated messages? shoudlnt happen

	m.msgs[msg.Hash].Acks = append(m.msgs[msg.Hash].Acks,
		Ack{
			container: msg.Container,
			time:      msg.Timestamp,
		})
}

func (m *MessageStats) TotalMessages() int {
	m.mutex.RLock()
	defer m.mutex.RUnlock()

	return len(m.msgs)
}

func (m *MessageStats) Stats() map[string]*IntervalStats {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	stats := make(map[string]*IntervalStats)
	for _, container := range m.receivers {
		stats[container] = &IntervalStats{
			MsgSent:     0,
			MsgReceived: 0,
			AvgDelay:    time.Duration(0),
		}
	}

	for hash, msg := range m.msgs {
		expireDeadLine := msg.Timestamp.Add(m.messageTimeout)
		// TODO: this wont be super precise for sub milisecond timeouts. this stamp is generated in this
		// container, but the rest were generated by the publisher/subs images.
		now := time.Now()
		if now.Compare(expireDeadLine) > 0 {
			//log.Info("msg acks: ", msg.Acks)
			// timeout expired
			// run stuff
			//log.Info("len acks", len(msg.Acks), " hash: ", msg.Hash)
			for _, ack := range msg.Acks {

				// This should not happen. Perhaps panic
				if msg.Timestamp.Compare(ack.time) > 0 {
					log.WithFields(log.Fields{
						"msgTime": msg.Timestamp,
						"ackTime": ack.time,
						"hash":    msg.Hash,
					}).Warn("Ack time is smaller than msg time")
				}

				stats[ack.container].MsgReceived++
				// TODO this is shit
				oldAvgFloatNs := float64(stats[ack.container].AvgDelay.Nanoseconds())
				newMasurementFloatNs := float64(ack.time.Nanosecond() - msg.Timestamp.Nanosecond())

				stats[ack.container].AvgDelay = time.Duration(ApproxAverage(oldAvgFloatNs, newMasurementFloatNs))
			}
			// TODO: remove message
			//msgCounted++
			// unsure if hacky. just count sent messages. todo: hacky
			for _, container := range m.receivers {
				stats[container].MsgSent++
			}

			// Msg is considered processed
			delete(m.msgs, hash)
		}
	}

	return stats
}

func (m *MessageStats) Containers() []string {
	//m.mutex.RLock()
	//defer m.mutex.RUnlock()
	// no need for lock, this is written just once non concurrently
	return m.receivers
}

// TODO: Some cleanups so that mem doesnt grow forever

func ApproxAverage(avg float64, newSample float64) float64 {
	// 1 to calculate avg, N>1 for moving average
	N := float64(1)

	avg -= avg / N
	avg += newSample / N

	return avg
}
